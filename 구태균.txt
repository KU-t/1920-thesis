이름     학번      email주소      핸드폰번호
----------------------------------------------
구태균  2014132002   jhltk2426@naver.com    010.7559.2426


2019-11-26
------------
1. 지도교수 변경 : 이용희 -> 정내훈
 - 졸업을 논문으로 할 예정
 - 멀티쓰레드 프로그래밍 관련 토픽으로 졸업 희망

2. 일단 주제를 lock free shared_ptr의 구현으로 잡음.
 - 이슈 : 현재의 shared_ptr는 멀티쓰레드 safe하지 않음
 - 목표 : Lock Free shared_ptr의 구현
 - 어려움 : shared_ptr와 weak_ptr의 연동이 lock free로 이루어져야 함.

3. 다음 미팅
 - shared_ptr와 weak_ptr가 무엇인지 공부하기
 - "멀티스레딩과 shared_ptr의 충돌 해결"를 보고 무엇을 해야 하는지 이해 하기
 - 2019-11-28일 목요일 오후 8시까지 위의 내용을 공부해 올것. 이후 발표자료 제작.

2019-11-28
------------
1. weak_ptr 란? 이해를 못하고 있음.

2. 12월 6일까지 PPT 제출

3. 12월 30일에 발표.

4. PPT작성
 -  서론(what?), 동기(why?), 배경 (shared_ptr, weak_ptr, lock_free), 관련연구(so far), 연구 방법(how?), 일정(when?)
     합해서  10페이지 정도.

5. 다음 미팅
 -  12월 2일 월요일 저녁 8시
 - PPT작성해 오기
 - GITHUB 프로젝트 하나 생성하기, 그리고 zzapuno@hotmail.com을 초대하기.


2019-12-02
-------------
1. PPT를 읽어서 이해가 될 수 있도록 하고, 자신이 발표할 수 있도록 내용을 다듬을 것.
 - 관련연구를 좀 자세히 적을 것.

2. 다음 미팅
 - 12월 16일 월요일 오후 7시
 - 관련연구를 읽어와서 발표하기. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.92.8221&rep=rep1&type=pdf

2019-12-16
-------------
1. 관련연구를 읽어와서 발표하기. Practical and Efﬁcient Lock-Free Garbage Collection Based on Reference Counting

2. 다음미팅 : 12월 26일 목요일 오후 5시
 - 12월 30일 발표자료 업데이트해서 가져올 것
 - 발표 예행 연습 예정 

2019-12-26
------------
1.  발표 자료 수정
 * 중복된 내용 제거
 * Example Code 추가
 * 설명의 간략화

2. 다음미팅 : 
 *  1월 13일 오후 2시
 * 연구한 내용 발표.(G++에서의 shared_ptr, weak_ptr 소스코드 분석내용)

2019-01-13
-------------
1. 제안서 발표 - 통과
 * 딱히 특별한 지적 사항은 없었음.

2. 작업일지 작성 시작
 * 샘플 서식에 맞춰서 매주 작성

3. 오늘 한것
 * using a = b;
   typedef b a; 와 같다. 그런데 좀더 템플릿에서 사용하기 편하다.

   typedef int a[100];
   using a = int[100];

 * remove_extent<T>::type;
   T가 배열이면 배열의 원소 타입을 리턴한다.
   type은 remove_extent 템플릿의 멤버의 이름이다.

 * enable_shared_from_this
   shared_ptr로 관리되는 객체가 내부에서 자기 자신의 shared_ptr를 얻고자 할 때 사용. 이게 없으면 자신의 shared_ptr가 무엇인지 내부에서 알 방법이 없다.

#include <iostream>
#include <memory>

class party;

class player
{
public:
	int id;
	std::shared_ptr<party> my_party;
	player(int id_): id (id_)
	{}
};


class party : public std::enable_shared_from_this<party>
{

	std::shared_ptr<player> member[5];
public:
	void add_memeber(std::shared_ptr<player> new_member)
	{
		member[0] = new_member;
		new_member->my_party = shared_from_this();
	}
};


int main()
{
	std::shared_ptr<player> p1 = std::make_shared<player>(1);
	std::shared_ptr<party> pt1 = std::make_shared<party>();
	pt1->add_memeber(p1);
}

4. 인터넷을 뒤져가면서 잘 공부해 올것.
 
5. 다음미팅
 - 2월 3일 오후 2시

2020-02-10
------------
1. 진행상황
 - shared_ptr 동작 분석
  * gcc쪽에 낮선 것들이 많이 보인다.

2. 낮선 것들
 - atomic_thread_fence(memory_order_acquire);
  * Out-of-order 실행으로 인한 메모리 접근순서 변경을 막는 명령어
  * _asm mfence와 같은 것
  * 하지만 mfence에는 여러 종류가 있다. (https://en.cppreference.com/w/cpp/atomic/memory_order)
    memory_order_relaxed : 실행순서 아무 상관 없음
    memory_order_consume : 더이상  안쓰임 
    memory_order_acquire : Lock에 해당하는 동기화, 동기화 이후에 있는 atomic연산들은 acquire가 끝난후 실행
    memory_order_release, : Unlock에 해당하는 동기화, 동기화 이전에 있는 atomic연산들이 모두 실행된 후 release실행
    memory_order_acq_rel : acquire와 release를 합한것. seq_cst와 
        다른 점은 서로다른 메모리에 접근하는 경우 쓰레드마다 순서가 다르게 보일 수 있다.
    memory_order_seq_cst  :  기본이고, 앞뒤의 모든 atomic operation의 실행순서를 분리. seq_cst가 적용된 메모리 접근은 모든 쓰레드에서 
       같은 순서로 실행된 것으로 보인다.

잘못된 코드 
  Thread A {
   int *data = &my_data;
   data_ready = true;
 }

 Thread B {
    if (true == data_ready) 
      cout << data;
 }

잘못된 코드 수정
  Thread A {
   int *data = &my_data;
   atomic_thread_fence(memory_order_release);
   data_ready = true;
 }

 Thread B {
    if (true == data_ready) {
    atomic_thread_fence(memory_order_acquire);
      cout << data;
   }
 }
   

 - GCC의 구현이 너무 양이 많다. 줄이자
  * Lock Policy중 single과 mutex를 없애는 것이 좋겠다.

 - EBO는 무엇인가?? Empty Based Optimization
  * 이런것 까지 신경 쓰지 않아도 좋을 듯

 - 별도의 deleter 적용 API들도 필요 없어 보임.

 - 꼭 필요한 핵심을 정의하고 그것만 구현하는 것이 필요
  * 일반 프로그램에서 많이 사용하는 것들
  * make_shared, shared_ptr<>, weak_ptr<>


3. 다음 미팅
 - GCC shared_ptr 분석
  * 호환성이나 확장성, 예외처리 부분을 제외한 핵심부분 분석
  * _Lock_policy와 deleter  삭제 (_Lock_policy는 atomic만 남김)
  * 구현이 필요한 method 분석
    - 생성자, Copy, Move, 소멸자
    - enable_shared_from_this는 나중에
 - 2월 26일 수요일 오후 4시


2020-03-09
------------
1. 진행상황
 - GCC에 있는 shared_ptr 소스코드를 Visual Studio에서 실행하려고 하는데 자꾸 컴파일에러가 난다.
  => 소스코드가 읽기 어려운 template programming방식이어서 이해하기가 너무 어렵다.

2. 대책
 - GCC에 있는 방대한 소스의 컴파일 버그를 찾으려는 노력보다는, 간단하게 shared_ptr를 구현하고 부족한 기능을 하나하나 추가해본다.
  필요한 기능을 추가하다가 보면 왜 Gcc 소스코드가 그렇게 되어 있는지 이해하게되고, 결국 GCC소스와 거의 같아지게 될 것이다.
 - 구현 단계
  * 생성자
  * = operator
  * 소멸자
  * atomic reference counting
  * get
  * * operator
  * -> operator
  * use_count
  * bool operator
  * make_shared
  * == operator
  * atomic_load
  * atomic_store
  * enable_shared_from_this

3. 다음 미팅
 - 3월 23일 월요일 오후 2시
 - 위의 구현단계에 적힌 것들을 구현해 오기.
 
2020-03-30
------------
1. 진행상황
 - 구현
  * shared_ptr다 구현
  * make_shared 구현
  * atomic_load, atomic_stre미구현
   => reference counter옆에 mutex를 두어서 그것으로 atomic구현
  * enable_shared_from_this는 VS구현이 너무 보기 힘들다.
 - 테스트프로그램
  * weak_ptr 구현
    => lock() 미구현

2. 다음미팅
 - enable shared from this 구현
 - 구현이 되면 Blcking Atomic Shared Pointer구현
 - 다음 미팅 4월 13일 (2시)

2020-04-13
-------------
1. 연구일지 매주 작성 필요

2. enable shared from this다음주 까지 구현
 - 기존의 구현이 복잡하고 생소한 요소들이 많기 때문에, 동작을 이해하고 차근차근 구현하는 것이 필요

3. 다음 미팅
 4월 20일 월요일 오후 2시 학교에서  (대면 수업 허가를 학교로 부터 받음)

2020-04-20
------------
1. 구태균 결석 : 몸이 아파서 결석, 가능하면 병결 출석인정원을 제출할 것

2. 연구일지 매주 작성 필요

3. 다음 미팅
 4월 27일 월요일 오후 2시 학교

2020-04-27
------------
1. 5월 11일 중간발표
 - 발표형식 미정 : 동영상 제출, 학교에서 한팀씩 들어와서 발표, 지도교수 판단.....

2. 진행상황
 - Blocking shared pointer 구현 : shared_ptr, make_shared, weak_ptr, enable_shared_from_this
 - 기본 데이터 Type에서 enable_shared_from_this가 안됨. => 구태균의 착각 기본데이터 타입에 enable_shared_from_this는 붙지 않는다.

    shared_ptr <int> sp_a = make_shared(int(1));
    shared_ptr <int> sp_b = sp_a;
    weak_ptr <int> wp_a = sp_a;
    weak_ptr <int> wp_b = wp_a;

 - 현재 주화입마에 빠져서 기본데이터의 ref_counter가 증가하지 않는 버그가 있는데, 수정할 것.
 - 컴파일 되면 안되는 오류코드가 컴파일됨 => 컴파일 에러를 내는 저주의 문장을 추가할 필요가 있음.

3. 중간 발표 준비
  ~ 4월 27일   : Blocking shared pointer 구현 : shared_ptr, make_shared, weak_ptr, enable_shared_from_this
  ~ 5월 4일    :  오류 수정, 발표자료 작성
  ~ 5월 11일   :  발표 준비.

4. 논문 제출 준비
 - 정보과학회 : 비슷한 짝퉁 학회들이 여러곳 있음.
 - 게임 학회 : 한국게임학회 (Korea Academic Society of Games), Journal of The Korean Society for Computer Game (KSCG), 
 - 일단은 학국게임확회를 목표로 작성하자 : 10월달까지 게제 여부가 결정되는 논문지의 제출 DeadLine알아보기..
    * 10월20일 게제이며, 제출 DeadLine은 9월 10일이다.

5.다음 미팅
 - 5월 4일 월요일 오후 2시 : 발표자료 작성, 벤치마크 프로그램을 작성해서 성능비교 해오기(std::shared_ptr와 비교)

        	std::atomic<std::shared_ptr<int>> a = std::make_shared<int> (10 );
	std::atomic<std::shared_ptr<int>> b = a.load();

6. 과제 수행 : 졸업할 때 까지. 80만원??? 5월이전에 결말.

2020-05-04
------------
1. 5월11일 중간발표
 - 지도교수 판단으로 넘김

2. 진행상황
 - Blocikingshared pointer구현: Release 모드에서 오류
 - 당연히 구현에 오류가 있는 것이고, cout으로 정보를 출력하면서 디버깅 해야 한다.

3. 다음 미팅
 - 5월 11일 월요일 7시



