이름     학번      email주소      핸드폰번호
----------------------------------------------
구태균  2014132002   jhltk2426@naver.com    010.7559.2426


2019-11-26
------------
1. 지도교수 변경 : 이용희 -> 정내훈
 - 졸업을 논문으로 할 예정
 - 멀티쓰레드 프로그래밍 관련 토픽으로 졸업 희망

2. 일단 주제를 lock free shared_ptr의 구현으로 잡음.
 - 이슈 : 현재의 shared_ptr는 멀티쓰레드 safe하지 않음
 - 목표 : Lock Free shared_ptr의 구현
 - 어려움 : shared_ptr와 weak_ptr의 연동이 lock free로 이루어져야 함.

3. 다음 미팅
 - shared_ptr와 weak_ptr가 무엇인지 공부하기
 - "멀티스레딩과 shared_ptr의 충돌 해결"를 보고 무엇을 해야 하는지 이해 하기
 - 2019-11-28일 목요일 오후 8시까지 위의 내용을 공부해 올것. 이후 발표자료 제작.

2019-11-28
------------
1. weak_ptr 란? 이해를 못하고 있음.

2. 12월 6일까지 PPT 제출

3. 12월 30일에 발표.

4. PPT작성
 -  서론(what?), 동기(why?), 배경 (shared_ptr, weak_ptr, lock_free), 관련연구(so far), 연구 방법(how?), 일정(when?)
     합해서  10페이지 정도.

5. 다음 미팅
 -  12월 2일 월요일 저녁 8시
 - PPT작성해 오기
 - GITHUB 프로젝트 하나 생성하기, 그리고 zzapuno@hotmail.com을 초대하기.


2019-12-02
-------------
1. PPT를 읽어서 이해가 될 수 있도록 하고, 자신이 발표할 수 있도록 내용을 다듬을 것.
 - 관련연구를 좀 자세히 적을 것.

2. 다음 미팅
 - 12월 16일 월요일 오후 7시
 - 관련연구를 읽어와서 발표하기. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.92.8221&rep=rep1&type=pdf

2019-12-16
-------------
1. 관련연구를 읽어와서 발표하기. Practical and Efﬁcient Lock-Free Garbage Collection Based on Reference Counting

2. 다음미팅 : 12월 26일 목요일 오후 5시
 - 12월 30일 발표자료 업데이트해서 가져올 것
 - 발표 예행 연습 예정 

2019-12-26
------------
1.  발표 자료 수정
 * 중복된 내용 제거
 * Example Code 추가
 * 설명의 간략화

2. 다음미팅 : 
 *  1월 13일 오후 2시
 * 연구한 내용 발표.(G++에서의 shared_ptr, weak_ptr 소스코드 분석내용)

2019-01-13
-------------
1. 제안서 발표 - 통과
 * 딱히 특별한 지적 사항은 없었음.

2. 작업일지 작성 시작
 * 샘플 서식에 맞춰서 매주 작성

3. 오늘 한것
 * using a = b;
   typedef b a; 와 같다. 그런데 좀더 템플릿에서 사용하기 편하다.

   typedef int a[100];
   using a = int[100];

 * remove_extent<T>::type;
   T가 배열이면 배열의 원소 타입을 리턴한다.
   type은 remove_extent 템플릿의 멤버의 이름이다.

 * enable_shared_from_this
   shared_ptr로 관리되는 객체가 내부에서 자기 자신의 shared_ptr를 얻고자 할 때 사용. 이게 없으면 자신의 shared_ptr가 무엇인지 내부에서 알 방법이 없다.

#include <iostream>
#include <memory>

class party;

class player
{
public:
	int id;
	std::shared_ptr<party> my_party;
	player(int id_): id (id_)
	{}
};


class party : public std::enable_shared_from_this<party>
{

	std::shared_ptr<player> member[5];
public:
	void add_memeber(std::shared_ptr<player> new_member)
	{
		member[0] = new_member;
		new_member->my_party = shared_from_this();
	}
};


int main()
{
	std::shared_ptr<player> p1 = std::make_shared<player>(1);
	std::shared_ptr<party> pt1 = std::make_shared<party>();
	pt1->add_memeber(p1);
}

4. 인터넷을 뒤져가면서 잘 공부해 올것.
 
5. 다음미팅
 - 2월 3일 오후 2시

2020-02-10
------------
1. 진행상황
 - shared_ptr 동작 분석
  * gcc쪽에 낮선 것들이 많이 보인다.

2. 낮선 것들
 - atomic_thread_fence(memory_order_acquire);
  * Out-of-order 실행으로 인한 메모리 접근순서 변경을 막는 명령어
  * _asm mfence와 같은 것
  * 하지만 mfence에는 여러 종류가 있다. (https://en.cppreference.com/w/cpp/atomic/memory_order)
    memory_order_relaxed : 실행순서 아무 상관 없음
    memory_order_consume : 더이상  안쓰임 
    memory_order_acquire : Lock에 해당하는 동기화, 동기화 이후에 있는 atomic연산들은 acquire가 끝난후 실행
    memory_order_release, : Unlock에 해당하는 동기화, 동기화 이전에 있는 atomic연산들이 모두 실행된 후 release실행
    memory_order_acq_rel : acquire와 release를 합한것. seq_cst와 
        다른 점은 서로다른 메모리에 접근하는 경우 쓰레드마다 순서가 다르게 보일 수 있다.
    memory_order_seq_cst  :  기본이고, 앞뒤의 모든 atomic operation의 실행순서를 분리. seq_cst가 적용된 메모리 접근은 모든 쓰레드에서 
       같은 순서로 실행된 것으로 보인다.

잘못된 코드 
  Thread A {
   int *data = &my_data;
   data_ready = true;
 }

 Thread B {
    if (true == data_ready) 
      cout << data;
 }

잘못된 코드 수정
  Thread A {
   int *data = &my_data;
   atomic_thread_fence(memory_order_release);
   data_ready = true;
 }

 Thread B {
    if (true == data_ready) {
    atomic_thread_fence(memory_order_acquire);
      cout << data;
   }
 }
   

 - GCC의 구현이 너무 양이 많다. 줄이자
  * Lock Policy중 single과 mutex를 없애는 것이 좋겠다.

 - EBO는 무엇인가?? Empty Based Optimization
  * 이런것 까지 신경 쓰지 않아도 좋을 듯

 - 별도의 deleter 적용 API들도 필요 없어 보임.

 - 꼭 필요한 핵심을 정의하고 그것만 구현하는 것이 필요
  * 일반 프로그램에서 많이 사용하는 것들
  * make_shared, shared_ptr<>, weak_ptr<>


3. 다음 미팅
 - GCC shared_ptr 분석
  * 호환성이나 확장성, 예외처리 부분을 제외한 핵심부분 분석
  * _Lock_policy와 deleter  삭제 (_Lock_policy는 atomic만 남김)
  * 구현이 필요한 method 분석
    - 생성자, Copy, Move, 소멸자
    - enable_shared_from_this는 나중에
 - 2월 26일 수요일 오후 4시


2020-03-09
------------
1. 진행상황
 - GCC에 있는 shared_ptr 소스코드를 Visual Studio에서 실행하려고 하는데 자꾸 컴파일에러가 난다.
  => 소스코드가 읽기 어려운 template programming방식이어서 이해하기가 너무 어렵다.

2. 대책
 - GCC에 있는 방대한 소스의 컴파일 버그를 찾으려는 노력보다는, 간단하게 shared_ptr를 구현하고 부족한 기능을 하나하나 추가해본다.
  필요한 기능을 추가하다가 보면 왜 Gcc 소스코드가 그렇게 되어 있는지 이해하게되고, 결국 GCC소스와 거의 같아지게 될 것이다.
 - 구현 단계
  * 생성자
  * = operator
  * 소멸자
  * atomic reference counting
  * get
  * * operator
  * -> operator
  * use_count
  * bool operator
  * make_shared
  * == operator
  * atomic_load
  * atomic_store
  * enable_shared_from_this

3. 다음 미팅
 - 3월 23일 월요일 오후 2시
 - 위의 구현단계에 적힌 것들을 구현해 오기.
 
2020-03-30
------------
1. 진행상황
 - 구현
  * shared_ptr다 구현
  * make_shared 구현
  * atomic_load, atomic_stre미구현
   => reference counter옆에 mutex를 두어서 그것으로 atomic구현
  * enable_shared_from_this는 VS구현이 너무 보기 힘들다.
 - 테스트프로그램
  * weak_ptr 구현
    => lock() 미구현

2. 다음미팅
 - enable shared from this 구현
 - 구현이 되면 Blcking Atomic Shared Pointer구현
 - 다음 미팅 4월 13일 (2시)

2020-04-13
-------------
1. 연구일지 매주 작성 필요

2. enable shared from this다음주 까지 구현
 - 기존의 구현이 복잡하고 생소한 요소들이 많기 때문에, 동작을 이해하고 차근차근 구현하는 것이 필요

3. 다음 미팅
 4월 20일 월요일 오후 2시 학교에서  (대면 수업 허가를 학교로 부터 받음)

2020-04-20
------------
1. 구태균 결석 : 몸이 아파서 결석, 가능하면 병결 출석인정원을 제출할 것

2. 연구일지 매주 작성 필요

3. 다음 미팅
 4월 27일 월요일 오후 2시 학교

2020-04-27
------------
1. 5월 11일 중간발표
 - 발표형식 미정 : 동영상 제출, 학교에서 한팀씩 들어와서 발표, 지도교수 판단.....

2. 진행상황
 - Blocking shared pointer 구현 : shared_ptr, make_shared, weak_ptr, enable_shared_from_this
 - 기본 데이터 Type에서 enable_shared_from_this가 안됨. => 구태균의 착각 기본데이터 타입에 enable_shared_from_this는 붙지 않는다.

    shared_ptr <int> sp_a = make_shared(int(1));
    shared_ptr <int> sp_b = sp_a;
    weak_ptr <int> wp_a = sp_a;
    weak_ptr <int> wp_b = wp_a;

 - 현재 주화입마에 빠져서 기본데이터의 ref_counter가 증가하지 않는 버그가 있는데, 수정할 것.
 - 컴파일 되면 안되는 오류코드가 컴파일됨 => 컴파일 에러를 내는 저주의 문장을 추가할 필요가 있음.

3. 중간 발표 준비
  ~ 4월 27일   : Blocking shared pointer 구현 : shared_ptr, make_shared, weak_ptr, enable_shared_from_this
  ~ 5월 4일    :  오류 수정, 발표자료 작성
  ~ 5월 11일   :  발표 준비.

4. 논문 제출 준비
 - 정보과학회 : 비슷한 짝퉁 학회들이 여러곳 있음.
 - 게임 학회 : 한국게임학회 (Korea Academic Society of Games), Journal of The Korean Society for Computer Game (KSCG), 
 - 일단은 학국게임확회를 목표로 작성하자 : 10월달까지 게제 여부가 결정되는 논문지의 제출 DeadLine알아보기..
    * 10월20일 게제이며, 제출 DeadLine은 9월 10일이다.

5.다음 미팅
 - 5월 4일 월요일 오후 2시 : 발표자료 작성, 벤치마크 프로그램을 작성해서 성능비교 해오기(std::shared_ptr와 비교)

        	std::atomic<std::shared_ptr<int>> a = std::make_shared<int> (10 );
	std::atomic<std::shared_ptr<int>> b = a.load();

6. 과제 수행 : 졸업할 때 까지. 80만원??? 5월이전에 결말.

2020-05-04
------------
1. 5월11일 중간발표
 - 지도교수 판단으로 넘김

2. 진행상황
 - Blocikingshared pointer구현: Release 모드에서 오류
 - 당연히 구현에 오류가 있는 것이고, cout으로 정보를 출력하면서 디버깅 해야 한다.

3. 다음 미팅
 - 5월 11일 월요일 7시


2020-05-11
-------------
1. 기획서 승인이 필요한데 통합정보시스템에서 구태균이 나오지 않음
 - 과사무실에 문의 했음.

2. 진행상황
 - Blocikingshared pointer구현: Release 모드에서 오류 => 수정
  * enable_shared_from_this에서 상속받은 객체의 경우 컨트롤 블럭을 2번 삭제하는 오류가 있었는데, 예외처리로 오류가 나오지 않도록 함.
  * 뜬금없이 control block이 생성되는 버그는 버그가 아니라 feature였음.
 - 모든 테스트 프로그램이 문제없이 실행?
  * NO : const reference로 매개변수를 넘겨 줄 때 컴파일 에러
   - 선언에 constexpr을 넣고 const 메소드들을 추가로 정의해 주어야 한다.
 - 런타임 에러 : head = nullptr에서 오류
  * nullptr_t를 매개변수로 받는 operator=를 정의해야 한다.
 - 런타임 에러 : 
       shared_ptr& operator=(const shared_ptr& other)
  * 위의 메소드에서 에러가 나는데, Data Race때문에 에러가 난다. Data Race를 잡도록, Lock의 보호 밖에서 수행되는 모든 operation은 위험하다!!!!!
   			if (curr_ctr) {
				if (false == curr_ctr->release())  // release에서 destory되면 false를 리턴
					curr_ctr->unlock();
			}
  * 위와 같은 방식으로 수정 필요.

3. 다음 미팅
 - 5월 18일 월요일 7시
 - 벤치마크프로그램이 실행될 때 까지 디버깅 해 올것.

2020-05-14
------------
1. 버그 수정
 - 싱글 쓰레드에서는 잘 돌아가는데 멀티쓰레드에서 오류가 난다.
 - 원인 : Contol Block에 있는 Lock으로 상호배제를 하고 있는데, 이것은 다시말하면 Control Block이 존재하지 않으면 상호배제를 하지 않는 다는 이야기이다.
   Thread A :   sp_a = nullptr;  sp_a = sp_b;
   Thread B :   sp_a = sp_c;
  위와 같은 코드에서 sp_a에 sp_b와 sp_c가 assign되는 것이 상호 배제 없이 동시에 실행되면서 Data Race가 발생하면서 오작동 한다.
 - 해결 방법 : shard_ptr 클래스에 mutex를 멤버로 두고 콘트롤 블록 존재 유무에 관계없이 모든 메소드에서 그 mutex로 상호 배제 하면서 동작해야 한다.

2. 과제 수행 (수익이 있는 곳에 일이 있다.)
 - 첫째 작업 : 자료 변환
  * 지하철을 운행하는 승무원의 운행스케줄 도표를 엑셀 표로 변환 


   예) 1번 승무원이 6시27분에 출근해서 
       왕십리 에서 열차를 07시에 타서 군자역에 07:25 도착  
       군자에서 10시 19분에 타서 고기역에 10:42분 도착
       고기역에서 16:42분에 타서 상일역에 16:47분 도착
       강동역에서 16:56분에 타서 답십리역에 17:51분 도착
       18:21분 퇴근
 - 월요일 미팅까지 해올것
 - 국가 2급 비밀이니 유출하지 말것.



2020-05-18
------------
1. 진행상황
 - mutex를 shared_ptr 클래스에 설치 ->잘 실행됨.
 - 성능? 멀티쓰레드일 때 std::shared_ptr를 atomic하게 사용한 것보다 성능이 좋음.
 
 - operator= 구현에서 임시 포인터 curr를 사용했는데 성능 저하???  => Release모드로 컴파일하면 컴파일러가 알아서 최적화 하므로 문제 없음
 - destructor()에서도 lock을 걸어야하는가? => reference counter를 감소 시킨 후 access하는 코드가 없어야 한다. 
                   그럴 경우 필요없다. destructor()는 싱글 스레드에서만 호출 된다.

2. Lock Free구현을 할 차례
 - Lock Free 구현의 필요성 : https://www.justsoftwaresolutions.co.uk/threading/why-do-we-need-atomic_shared_ptr.html
 - Lock Free Shared Pointer 구현 논문 : https://pdfs.semanticscholar.org/80d2/3837377503c3343e4117f5069fba816faac7.pdf

3. 다음 미팅
- 2번의 blog와 논문을 읽고 내용을 발표할 것.

4. 과제 수행
 - 다음주 월요일 까지 답십리 자료 입력해올것.

2020-05-25
------------
1. 진행상황
 - https://pdfs.semanticscholar.org/80d2/3837377503c3343e4117f5069fba816faac7.pdf 가 shared_ptr에 대한 논문이 아니라,  링크로 연결된 노드들로 이루어진
  자료구조에서 ref_counting으로 메모리 재상용문제를 해결하는 논문

2. 읽어 볼것
 - Lock Free 구현의 필요성 : https://www.justsoftwaresolutions.co.uk/threading/why-do-we-need-atomic_shared_ptr.html

3. Shared_ptr을 lock free로 어떻게 구현할지 고민 해 볼것
 - Lock Free로 구현하는 것이 어떠한 이유로 어려운지. 장애물들을 찾아서 적어 볼것

4. 다음 미팅
 2를 일고 3번을 고민한 내용을 이야기 할 것

5. 과제 수행
 - 다음주 월요일 까지 답십리 자료 입력해 올것.
